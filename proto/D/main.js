// Generated by CoffeeScript 1.6.2
var Atom, H, MODE, MOUSEDOWN, R, Structure, W, a, camera, face1, face2, light1, light2, mat1, mat2, mouse, onDocumentMouseDown, onDocumentMouseMove, onDocumentMouseUp, projector, r, render, renderer, s, scene, structure,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

R = 1.0;

r = R / 2.0;

s = Math.sqrt(3.0);

a = R * s;

W = window.innerWidth;

H = window.innerHeight;

MOUSEDOWN = false;

MODE = "ON";

mat1 = new THREE.MeshPhongMaterial({
  color: 0x000000,
  ambient: 0x888888,
  specular: 0xffffff,
  shininess: 250,
  side: THREE.DoubleSide,
  vertexColors: THREE.VertexColors
});

mat2 = new THREE.MeshPhongMaterial({
  color: 0xCC2244,
  ambient: 0x444444,
  specular: 0xffffff,
  shininess: 250,
  side: THREE.DoubleSide,
  vertexColors: THREE.VertexColors
});

face1 = new THREE.Geometry();

face1.vertices.push(new THREE.Vector3(0, R, 0));

face1.vertices.push(new THREE.Vector3(-a / 2, -r, 0));

face1.vertices.push(new THREE.Vector3(a / 2, -r, 0));

face1.faces.push(new THREE.Face3(0, 1, 2));

face1.computeFaceNormals();

face2 = new THREE.Geometry();

face2.vertices.push(new THREE.Vector3(0, -R, 0));

face2.vertices.push(new THREE.Vector3(a / 2, r, 0));

face2.vertices.push(new THREE.Vector3(-a / 2, r, 0));

face2.faces.push(new THREE.Face3(0, 1, 2));

face2.computeFaceNormals();

scene = new THREE.Scene();

camera = new THREE.PerspectiveCamera(45, W / H, 0.1, 1000);

camera.position.y = 0;

camera.position.z = 40;

scene.add(new THREE.AmbientLight(0x444444));

light1 = new THREE.DirectionalLight(0xFFCCAA, 1.5);

light1.position.set(0, 15, 15);

scene.add(light1);

light2 = new THREE.DirectionalLight(0x4422CC, 1.5);

light2.position.set(0, -15, 15);

scene.add(light2);

renderer = new THREE.WebGLRenderer();

renderer.setSize(W, H);

projector = new THREE.Projector();

mouse = new THREE.Vector3();

document.body.appendChild(renderer.domElement);

Atom = (function(_super) {
  __extends(Atom, _super);

  Atom.meshes = [];

  function Atom(i, j) {
    var mat;

    this.i = i;
    this.j = j;
    this.setOff = __bind(this.setOff, this);
    this.setOn = __bind(this.setOn, this);
    this.toggle = __bind(this.toggle, this);
    Atom.__super__.constructor.call(this);
    this.d = Math.abs((this.i + this.j + 1) % 2);
    this.position.x = this.i * a / 2.0;
    this.position.y = this.j * a / 2.0 * s + this.d * R / 2.0;
    this.position.x *= 1.1;
    this.position.y *= 1.1;
    this.on = false;
    mat = this.on ? mat2 : mat1;
    this.face = Math.abs((this.j + this.i) % 2) ? face1 : face2;
    Atom.meshes.push(this.mesh = new THREE.Mesh(this.face, mat));
    this.mesh.atom = this;
    this.add(this.mesh);
  }

  Atom.prototype.toggle = function() {
    this.on = !this.on;
    return this.mesh.material = this.on ? mat2 : mat1;
  };

  Atom.prototype.setOn = function() {
    this.on = true;
    return this.mesh.material = mat2;
  };

  Atom.prototype.setOff = function() {
    this.on = false;
    return this.mesh.material = mat1;
  };

  return Atom;

})(THREE.Object3D);

Structure = (function(_super) {
  __extends(Structure, _super);

  Structure.prototype.atoms = {};

  function Structure() {
    this.cellularCalcs = __bind(this.cellularCalcs, this);
    var A, atom, i, j, l, _i, _j, _ref;

    Structure.__super__.constructor.call(this);
    this.rotation.z = Math.PI;
    A = 4;
    for (j = _i = _ref = -A * 2; _ref <= A ? _i <= A : _i >= A; j = _ref <= A ? ++_i : --_i) {
      l = 2 * A + j;
      for (i = _j = -l; -l <= l ? _j <= l : _j >= l; i = -l <= l ? ++_j : --_j) {
        this.add(atom = new Atom(i, j));
        this.atoms["" + i + ":" + j] = atom;
      }
    }
  }

  Structure.prototype.cellularCalcs = function() {
    var i, x, y, z, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results;

    if (MOUSEDOWN) {
      return;
    }
    _ref = this.atoms;
    for (i in _ref) {
      a = _ref[i];
      x = (_ref1 = this.atoms["" + (a.i - 1) + ":" + a.j]) != null ? _ref1.on : void 0;
      y = (_ref2 = this.atoms["" + (a.i + 1) + ":" + a.j]) != null ? _ref2.on : void 0;
      z = a.d ? (_ref3 = this.atoms["" + a.i + ":" + (a.j + 1)]) != null ? _ref3.on : void 0 : (_ref4 = this.atoms["" + a.i + ":" + (a.j - 1)]) != null ? _ref4.on : void 0;
      a.c = (x | 0) + (y | 0) + (z | 0);
    }
    _ref5 = this.atoms;
    _results = [];
    for (i in _ref5) {
      a = _ref5[i];
      switch (a.c) {
        case 0:
          if (a.on) {
            _results.push(a.toggle());
          } else {
            _results.push(void 0);
          }
          break;
        case 2:
          if (!a.on) {
            _results.push(a.toggle());
          } else {
            _results.push(void 0);
          }
          break;
        case 3:
          if (a.on) {
            _results.push(a.setOff());
          } else {
            _results.push(void 0);
          }
          break;
        default:
          _results.push(void 0);
      }
    }
    return _results;
  };

  return Structure;

})(THREE.Object3D);

onDocumentMouseDown = function(e) {
  var intersects, raycaster;

  e.preventDefault();
  MOUSEDOWN = true;
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  mouse.z = 0.5;
  projector.unprojectVector(mouse, camera);
  console.log(mouse);
  raycaster = new THREE.Raycaster(camera.position, mouse.sub(camera.position).normalize());
  intersects = raycaster.intersectObjects(Atom.meshes);
  if (intersects.length > 0) {
    if (intersects[0].object.atom.on) {
      intersects[0].object.atom.setOff();
      return MODE = "OFF";
    } else {
      intersects[0].object.atom.setOn();
      return MODE = "ON";
    }
  } else {
    MODE = "ON";
    return console.log(intersects[0].object.atom.c);
  }
};

onDocumentMouseUp = function(e) {
  e.preventDefault();
  return MOUSEDOWN = false;
};

onDocumentMouseMove = function(e) {
  var intersects, raycaster;

  e.preventDefault();
  if (MOUSEDOWN) {
    mouse.x = (e.clientX / W) * 2 - 1;
    mouse.y = -(e.clientY / H) * 2 + 1;
    mouse.z = 0.5;
    projector.unprojectVector(mouse, camera);
    raycaster = new THREE.Raycaster(camera.position, mouse.sub(camera.position).normalize());
    intersects = raycaster.intersectObjects(Atom.meshes);
    if (intersects.length > 0) {
      renderer.domElement.style.cursor = 'pointer';
      if (MODE === "ON") {
        return intersects[0].object.atom.setOn();
      } else {
        return intersects[0].object.atom.setOff();
      }
    } else {
      return renderer.domElement.style.cursor = 'auto';
    }
  }
};

render = function() {
  requestAnimationFrame(render);
  return renderer.render(scene, camera);
};

structure = new Structure;

scene.add(structure);

renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);

renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);

renderer.domElement.addEventListener('mouseup', onDocumentMouseUp, false);

setInterval(structure.cellularCalcs, 100);

render();
