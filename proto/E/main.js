// Generated by CoffeeScript 1.6.2
var Atom, H, Hole, MODE, MOUSEDOWN, R, Structure, W, a, camera, face1, face2, light1, light2, mat1, mat2, mat3, mouse, onDocumentMouseDown, onDocumentMouseMove, onDocumentMouseUp, projector, r, render, renderer, s, scene, structure,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

R = 1.0;

r = R / 2.0;

s = Math.sqrt(3.0);

a = R * s;

W = window.innerWidth;

H = window.innerHeight;

MOUSEDOWN = false;

MODE = "ON";

mat1 = new THREE.MeshBasicMaterial({
  color: 0xAAAAAA
});

mat2 = new THREE.MeshBasicMaterial({
  color: 0xCC2244
});

mat3 = new THREE.MeshBasicMaterial({
  color: 0xEEEEEE
});

face1 = new THREE.Geometry();

face1.vertices.push(new THREE.Vector3(0, R, 0));

face1.vertices.push(new THREE.Vector3(-a / 2, -r, 0));

face1.vertices.push(new THREE.Vector3(a / 2, -r, 0));

face1.faces.push(new THREE.Face3(0, 1, 2));

face1.computeFaceNormals();

face2 = new THREE.Geometry();

face2.vertices.push(new THREE.Vector3(0, -R, 0));

face2.vertices.push(new THREE.Vector3(a / 2, r, 0));

face2.vertices.push(new THREE.Vector3(-a / 2, r, 0));

face2.faces.push(new THREE.Face3(0, 1, 2));

face2.computeFaceNormals();

scene = new THREE.Scene();

camera = new THREE.PerspectiveCamera(45, W / H, 0.1, 1000);

camera.position.y = 0;

camera.position.z = 40;

scene.add(new THREE.AmbientLight(0x444444));

light1 = new THREE.DirectionalLight(0xFFCCAA, 1.5);

light1.position.set(0, 15, 15);

scene.add(light1);

light2 = new THREE.DirectionalLight(0x4422CC, 1.5);

light2.position.set(0, -15, 15);

scene.add(light2);

renderer = new THREE.CanvasRenderer();

renderer.setSize(W, H);

projector = new THREE.Projector();

mouse = new THREE.Vector3();

document.body.appendChild(renderer.domElement);

Atom = (function(_super) {
  __extends(Atom, _super);

  Atom.meshes = [];

  function Atom(i, j) {
    var mat;

    this.i = i;
    this.j = j;
    this.setOff = __bind(this.setOff, this);
    this.setOn = __bind(this.setOn, this);
    this.toggle = __bind(this.toggle, this);
    Atom.__super__.constructor.call(this);
    this.d = Math.abs((this.i + this.j + 1) % 2);
    this.position.x = this.i * a / 2.0;
    this.position.y = this.j * a / 2.0 * s + this.d * R / 2.0;
    this.position.x *= 1.1;
    this.position.y *= 1.1;
    this.on = false;
    mat = this.on ? mat2 : mat1;
    this.face = Math.abs((this.j + this.i) % 2) ? face1 : face2;
    Atom.meshes.push(this.mesh = new THREE.Mesh(this.face, mat));
    this.mesh.atom = this;
    this.add(this.mesh);
  }

  Atom.prototype.toggle = function() {
    this.on = !this.on;
    return this.mesh.material = this.on ? mat2 : mat1;
  };

  Atom.prototype.setOn = function() {
    this.on = true;
    return this.mesh.material = mat2;
  };

  Atom.prototype.setOff = function() {
    this.on = false;
    return this.mesh.material = mat1;
  };

  return Atom;

})(THREE.Object3D);

Hole = (function(_super) {
  __extends(Hole, _super);

  Hole.meshes = [];

  function Hole(i, j) {
    var mat;

    this.i = i;
    this.j = j;
    Hole.__super__.constructor.call(this);
    console.log("H " + this.i + " " + this.j);
    this.d = Math.abs((this.i + this.j + 1) % 2);
    this.position.x = this.i * a / 2.0;
    this.position.y = this.j * a / 2.0 * s + this.d * R / 2.0;
    this.position.x *= 1.1;
    this.position.y *= 1.1;
    mat = mat3;
    this.face = Math.abs((this.j + this.i) % 2) ? face1 : face2;
    Hole.meshes.push(this.mesh = new THREE.Mesh(this.face, mat));
    this.mesh.hole = this;
    this.add(this.mesh);
  }

  return Hole;

})(THREE.Object3D);

Structure = (function(_super) {
  __extends(Structure, _super);

  Structure.prototype.atoms = {};

  Structure.prototype.holes = {};

  function Structure() {
    this.cellularCalcs = __bind(this.cellularCalcs, this);
    this.addAtom = __bind(this.addAtom, this);
    var A, i, j, l, _i, _j, _ref;

    Structure.__super__.constructor.call(this);
    this.rotation.z = Math.PI;
    A = 3;
    for (j = _i = _ref = -A * 2; _ref <= A ? _i <= A : _i >= A; j = _ref <= A ? ++_i : --_i) {
      l = 2 * A + j;
      for (i = _j = -l; -l <= l ? _j <= l : _j >= l; i = -l <= l ? ++_j : --_j) {
        this.addAtom(i, j);
      }
    }
  }

  Structure.prototype.addAtom = function(i, j) {
    console.log("A " + i + " " + j);
    if (this.holes["" + i + ":" + j]) {
      this.remove(this.holes["" + i + ":" + j]);
      delete this.holes["" + i + ":" + j];
    }
    this.add(this.atoms["" + i + ":" + j] = new Atom(i, j));
    if (this.atoms["" + i + ":" + j].d) {
      if (!(this.holes["" + i + ":" + (j + 1)] || this.atoms["" + i + ":" + (j + 1)])) {
        this.add(this.holes["" + i + ":" + (j + 1)] = new Hole(i, j + 1));
      }
    } else {
      if (!(this.holes["" + i + ":" + (j - 1)] || this.atoms["" + i + ":" + (j - 1)])) {
        this.add(this.holes["" + i + ":" + (j - 1)] = new Hole(i, j - 1));
      }
    }
    if (!(this.holes["" + (i - 1) + ":" + j] || this.atoms["" + (i - 1) + ":" + j])) {
      this.add(this.holes["" + (i - 1) + ":" + j] = new Hole(i - 1, j));
    }
    if (!(this.holes["" + (i + 1) + ":" + j] || this.atoms["" + (i + 1) + ":" + j])) {
      return this.add(this.holes["" + (i + 1) + ":" + j] = new Hole(i + 1, j));
    }
  };

  Structure.prototype.cellularCalcs = function() {
    var atom, id, x, y, z, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results;

    if (MOUSEDOWN) {
      return;
    }
    _ref = this.atoms;
    for (id in _ref) {
      atom = _ref[id];
      x = (_ref1 = this.atoms["" + (atom.i - 1) + ":" + atom.j]) != null ? _ref1.on : void 0;
      y = (_ref2 = this.atoms["" + (atom.i + 1) + ":" + atom.j]) != null ? _ref2.on : void 0;
      z = atom.d ? (_ref3 = this.atoms["" + atom.i + ":" + (atom.j + 1)]) != null ? _ref3.on : void 0 : (_ref4 = this.atoms["" + atom.i + ":" + (atom.j - 1)]) != null ? _ref4.on : void 0;
      atom.siblings = (x | 0) + (y | 0) + (z | 0);
    }
    _ref5 = this.atoms;
    _results = [];
    for (id in _ref5) {
      atom = _ref5[id];
      switch (atom.siblings) {
        case 0:
          if (atom.on) {
            _results.push(atom.setOff());
          } else {
            _results.push(void 0);
          }
          break;
        case 2:
          if (!atom.on) {
            _results.push(atom.setOn());
          } else {
            _results.push(void 0);
          }
          break;
        case 3:
          if (atom.on) {
            _results.push(atom.setOff());
          } else {
            _results.push(void 0);
          }
          break;
        default:
          _results.push(void 0);
      }
    }
    return _results;
  };

  return Structure;

})(THREE.Object3D);

onDocumentMouseDown = function(e) {
  var hole, intersects, raycaster;

  e.preventDefault();
  MOUSEDOWN = true;
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  mouse.z = 0.5;
  projector.unprojectVector(mouse, camera);
  console.log(mouse);
  raycaster = new THREE.Raycaster(camera.position, mouse.sub(camera.position).normalize());
  intersects = raycaster.intersectObjects(Atom.meshes);
  if (intersects.length > 0) {
    if (intersects[0].object.atom.on) {
      intersects[0].object.atom.setOff();
      MODE = "OFF";
    } else {
      intersects[0].object.atom.setOn();
      MODE = "ON";
    }
    return;
  } else {
    MODE = "ON";
  }
  intersects = raycaster.intersectObjects(Hole.meshes);
  if (intersects.length > 0) {
    hole = intersects[0].object.hole;
    structure.addAtom(hole.i, hole.j);
  }
};

onDocumentMouseUp = function(e) {
  e.preventDefault();
  return MOUSEDOWN = false;
};

onDocumentMouseMove = function(e) {
  var intersects, raycaster;

  e.preventDefault();
  if (MOUSEDOWN) {
    mouse.x = (e.clientX / W) * 2 - 1;
    mouse.y = -(e.clientY / H) * 2 + 1;
    mouse.z = 0.5;
    projector.unprojectVector(mouse, camera);
    raycaster = new THREE.Raycaster(camera.position, mouse.sub(camera.position).normalize());
    intersects = raycaster.intersectObjects(Atom.meshes);
    if (intersects.length > 0) {
      renderer.domElement.style.cursor = 'pointer';
      if (MODE === "ON") {
        return intersects[0].object.atom.setOn();
      } else {
        return intersects[0].object.atom.setOff();
      }
    } else {
      return renderer.domElement.style.cursor = 'auto';
    }
  }
};

render = function() {
  requestAnimationFrame(render);
  return renderer.render(scene, camera);
};

structure = new Structure;

scene.add(structure);

renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);

renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);

renderer.domElement.addEventListener('mouseup', onDocumentMouseUp, false);

setInterval(structure.cellularCalcs, 100);

render();
