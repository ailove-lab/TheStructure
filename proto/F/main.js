// Generated by CoffeeScript 1.6.2
var Atom, H, Hole, MODE, MOUSEDOWN, PI2, R, Structure, W, a, baricentricPoint, baricentricToCartesian, buildFace, camera, cartesianToBaricetric, cartesianToIndex, colors, cor, cortesianPoint, d, dot, geom, i, indexToCartesian, j, len, light1, light2, line, marker, mat1, mat2, mat3, mouse, onDocumentMouseDown, onDocumentMouseMove, progA, progB, progFill, progFillSmall, progStroke, projector, r, render, renderer, s, scene, step, structure, u, v, x, y, z, _i, _j, _k, _l, _m, _ref, _ref1,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

R = 1.0;

r = R / 2.0;

s = Math.sqrt(3.0);

a = R * s;

W = window.innerWidth;

H = window.innerHeight;

MOUSEDOWN = false;

MODE = "ON";

colors = [0xEE2244, 0x88CC44, 0x4488EE, 0xEE8844];

mat1 = new THREE.MeshBasicMaterial({
  color: 0xAAAAAA,
  opacity: 0.5
});

mat2 = new THREE.MeshBasicMaterial({
  color: 0xCC2244,
  opacity: 0.75
});

mat3 = new THREE.MeshBasicMaterial({
  color: 0xEEEEEE,
  opacity: 0.75
});

scene = new THREE.Scene();

camera = new THREE.PerspectiveCamera(45, W / H, 1, 1000);

camera.position.y = 0;

camera.position.z = 10;

scene.add(new THREE.AmbientLight(0x444444));

light1 = new THREE.DirectionalLight(0xFFCCAA, 1.5);

light1.position.set(0, 15, 15);

scene.add(light1);

light2 = new THREE.DirectionalLight(0x4422CC, 1.5);

light2.position.set(0, -15, 15);

scene.add(light2);

renderer = new THREE.CanvasRenderer();

renderer.setSize(W, H);

projector = new THREE.Projector();

mouse = new THREE.Vector3();

document.body.appendChild(renderer.domElement);

PI2 = 3.141592654 * 2;

progA = function(ctx) {
  var z;

  z = 1;
  ctx.beginPath();
  ctx.moveTo(0, R * z);
  ctx.lineTo(-a / 2 * z, -r * z);
  ctx.lineTo(a / 2 * z, -r * z);
  ctx.closePath();
  return ctx.fill();
};

progB = function(ctx) {
  var z;

  z = 1;
  ctx.beginPath();
  ctx.moveTo(0, -R * z);
  ctx.lineTo(a / 2 * z, r * z);
  ctx.lineTo(-a / 2 * z, r * z);
  ctx.closePath();
  return ctx.fill();
};

progFill = function(ctx) {
  ctx.beginPath();
  ctx.arc(0, 0, r / 2, 0, PI2, true);
  ctx.closePath();
  return ctx.fill();
};

progFillSmall = function(ctx) {
  ctx.beginPath();
  ctx.arc(0, 0, r / 4, 0, PI2, true);
  ctx.closePath();
  return ctx.fill();
};

progStroke = function(ctx) {
  ctx.lineWidth = 1.0;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, PI2, true);
  ctx.closePath();
  return ctx.stroke();
};

marker = new THREE.Particle(new THREE.ParticleCanvasMaterial({
  color: 0x404040,
  program: progStroke
}));

scene.add(marker);

buildFace = function(d, z) {
  var face;

  face = new THREE.Geometry();
  if (d) {
    face.vertices.push(new THREE.Vector3(0, R * z, 0));
    face.vertices.push(new THREE.Vector3(-a / 2 * z, -r * z, 0));
    face.vertices.push(new THREE.Vector3(a / 2 * z, -r * z, 0));
  } else {
    face.vertices.push(new THREE.Vector3(0, -R * z, 0));
    face.vertices.push(new THREE.Vector3(a / 2 * z, r * z, 0));
    face.vertices.push(new THREE.Vector3(-a / 2 * z, r * z, 0));
  }
  face.faces.push(new THREE.Face3(0, 1, 2));
  face.computeFaceNormals();
  return face;
};

dot = function(x1, y1, x2, y2) {
  return x1 * x2 + y1 * y2;
};

cartesianToBaricetric = function(x, y, x1, y1, x2, y2, x3, y3) {
  var d, u, v, w, x13, x23, xx3, y13, y23, yy3;

  x13 = x1 - x3;
  y13 = y1 - y3;
  x23 = x2 - x3;
  y23 = y2 - y3;
  xx3 = x - x3;
  yy3 = y - y3;
  d = y23 * x13 - x23 * y13;
  u = (y23 * xx3 - x23 * yy3) / d;
  v = (x13 * yy3 - y13 * xx3) / d;
  w = 1 - u - v;
  return {
    u: u,
    v: v,
    w: w
  };
};

baricentricToCartesian = function(u, v, x1, y1, x2, y2, x3, y3) {
  var w;

  w = 1 - u - v;
  return {
    x: x1 * u + x2 * v + x3 * w,
    y: y1 * u + y2 * v + y3 * w
  };
};

indexToCartesian = function(i, j) {
  var d;

  d = Math.abs((i + j + 1) % 2);
  return {
    x: i * a / 2.0 * z,
    y: j * a / 2.0 * z * s + r * (d * z - 1)
  };
};

cartesianToIndex = function(x, y) {
  var d, i, j, k, z;

  z = 1;
  k = 2 / a / z;
  i = x * k;
  j = y * k / s;
  d = Math.abs((i + 1) % 2);
  return {
    i: i,
    j: j
  };
};

Atom = (function(_super) {
  __extends(Atom, _super);

  Atom.meshes = [];

  function Atom(i, j, k) {
    var mat, p;

    this.i = i;
    this.j = j;
    this.k = k != null ? k : 0;
    this.setOff = __bind(this.setOff, this);
    this.setOn = __bind(this.setOn, this);
    this.toggle = __bind(this.toggle, this);
    Atom.__super__.constructor.call(this);
    this.z = Math.pow(2, this.k);
    this.d = Math.abs((this.i + this.j + 1) % 2);
    this.position.x = this.i * a / 2.0 * this.z;
    this.position.y = this.j * a / 2.0 * s * this.z + r * (this.d * this.z - 1);
    this.on = false;
    mat = this.on ? mat2 : mat1;
    this.face = buildFace(Math.abs((this.j + this.i) % 2), this.z * 0.98);
    Atom.meshes.push(this.mesh = new THREE.Mesh(this.face, mat));
    this.mesh.atom = this;
    this.add(this.mesh);
    scene.add(p = new THREE.Particle(new THREE.ParticleCanvasMaterial({
      color: 0x808080,
      opacity: 0.25,
      program: progFill
    })));
    p.position.x = this.position.x;
    p.position.y = -this.position.y;
  }

  Atom.prototype.toggle = function() {
    this.on = !this.on;
    return this.mesh.material = this.on ? mat2 : mat1;
  };

  Atom.prototype.setOn = function() {
    this.on = true;
    return this.mesh.material = mat2;
  };

  Atom.prototype.setOff = function() {
    this.on = false;
    return this.mesh.material = mat1;
  };

  return Atom;

})(THREE.Object3D);

Hole = (function(_super) {
  __extends(Hole, _super);

  Hole.meshes = [];

  function Hole(i, j) {
    var mat;

    this.i = i;
    this.j = j;
    Hole.__super__.constructor.call(this);
    this.d = Math.abs((this.i + this.j + 1) % 2);
    this.position.x = this.i * a / 2.0;
    this.position.y = this.j * a / 2.0 * s + this.d * R / 2.0;
    mat = mat3;
    this.face = buildFace(Math.abs((this.j + this.i) % 2), 1);
    Hole.meshes.push(this.mesh = new THREE.Mesh(this.face, mat));
    this.mesh.hole = this;
    this.add(this.mesh);
  }

  return Hole;

})(THREE.Object3D);

Structure = (function(_super) {
  __extends(Structure, _super);

  Structure.prototype.atoms = {};

  Structure.prototype.holes = {};

  function Structure() {
    this.addAtom = __bind(this.addAtom, this);
    var A, i, j, l, _i, _j, _ref;

    Structure.__super__.constructor.call(this);
    this.rotation.z = Math.PI;
    A = 1;
    for (j = _i = _ref = -A * 2; _ref <= A ? _i <= A : _i >= A; j = _ref <= A ? ++_i : --_i) {
      l = 2 * A + j;
      for (i = _j = -l; -l <= l ? _j <= l : _j >= l; i = -l <= l ? ++_j : --_j) {
        this.addAtom(i, j);
      }
    }
  }

  Structure.prototype.addAtom = function(i, j) {
    return this.add(this.atoms["" + i + ":" + j] = new Atom(i, j));
  };

  return Structure;

})(THREE.Object3D);

onDocumentMouseDown = function(e) {
  var bar, cor, m, o, p, u, v, w, x0, y0, z;

  e.preventDefault();
  m = new THREE.Vector3;
  m.x = (e.clientX / window.innerWidth) * 2 - 1;
  m.y = -(e.clientY / window.innerHeight) * 2 + 1;
  m.z = 0.5;
  projector.unprojectVector(m, camera);
  o = camera.position;
  x0 = o.z * m.x / (o.z - m.z);
  y0 = o.z * m.y / (o.z - m.z);
  z = 1;
  bar = cartesianToBaricetric(x0, y0, 0, R * z, -a / 2 * z, -r * z, a / 2 * z, -r * z);
  u = Math.round(bar.u * 3) / 3;
  v = Math.round(bar.v * 3) / 3;
  w = Math.round(bar.w * 3) / 3;
  cor = baricentricToCartesian(u, v, 0, R * z, -a / 2 * z, -r * z, a / 2 * z, -r * z);
  p = new THREE.Particle(new THREE.ParticleCanvasMaterial({
    color: colors[Math.random() * colors.length | 0],
    opacity: 0.75,
    program: progFill
  }));
  p.position.x = cor.x;
  p.position.y = cor.y;
  return scene.add(p);
};

onDocumentMouseMove = function(e) {
  var bar, cor, d, inc, m, o, u, v, w, x0, y0, z;

  e.preventDefault();
  m = new THREE.Vector3;
  m.x = (e.clientX / window.innerWidth) * 2 - 1;
  m.y = -(e.clientY / window.innerHeight) * 2 + 1;
  m.z = 0.5;
  projector.unprojectVector(m, camera);
  o = camera.position;
  x0 = o.z * m.x / (o.z - m.z);
  y0 = o.z * m.y / (o.z - m.z);
  z = 4;
  bar = cartesianToBaricetric(x0, y0, 0, R * z, -a / 2 * z, -r * z, a / 2 * z, -r * z);
  u = Math.floor(bar.u * 4);
  v = Math.floor(bar.v * 4);
  w = Math.floor(bar.w * 4);
  console.log(u, v, w, u + v + w);
  d = (u + v + w) % 2;
  inc = d ? 1 / 3 : 2 / 3;
  cor = baricentricToCartesian((u + inc) / 4, (v + inc) / 4, 0, R * z, -a / 2 * z, -r * z, a / 2 * z, -r * z);
  marker.position.x = cor.x;
  marker.position.y = cor.y;
  return document.getElementById("text").innerText = "u + v + w = 1\n" + (u.toFixed(0)) + " + " + (v.toFixed(0)) + " + " + (w.toFixed(0)) + " = " + ((u + v + w).toFixed(0)) + "\n" + ((1 - u * 3).toFixed(0)) + " + " + ((1 - v * 3).toFixed(0)) + " + " + ((1 - w * 3).toFixed(0)) + " = 0\n" + (u * 3 % 3) + " + " + (v * 3 % 3) + " + " + (w * 3 % 3) + "\n" + ((bar.u * 3).toFixed(3)) + " + " + ((bar.v * 3).toFixed(3)) + " + " + ((bar.w * 3).toFixed(3)) + " = " + ((bar.u + bar.v + bar.w).toFixed(3));
};

render = function() {
  requestAnimationFrame(render);
  return renderer.render(scene, camera);
};

structure = new Structure;

scene.add(structure);

renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);

renderer.domElement.addEventListener('mousedown', onDocumentMouseDown, false);

render();

for (i = _i = 0, _ref = step = 3; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
  j = i / step;
  z = 4;
  geom = new THREE.Geometry();
  geom.vertices.push(new THREE.Vector3(0, R * z, 0));
  geom.vertices.push(new THREE.Vector3(-a / 2 * z, -r * z, 0));
  geom.vertices.push(new THREE.Vector3(a / 2 * z, -r * z, 0));
  geom.vertices.push(new THREE.Vector3(0, R * z, 0));
  line = new THREE.Line(geom, new THREE.LineBasicMaterial({
    color: 0x404040,
    opacity: 0.25
  }));
  scene.add(line);
  geom = new THREE.Geometry();
  cor = baricentricToCartesian(1 / 3, 1 / 3, 0, R * z, -a / 2 * z, -r * z, a / 2 * z, -r * z);
  geom.vertices.push(new THREE.Vector3(cor.x, cor.y, 0));
  cor = baricentricToCartesian(1 - j, j / 2, 0, R * z, -a / 2 * z, -r * z, a / 2 * z, -r * z);
  len = Math.sqrt(cor.x * cor.x + cor.y * cor.y) * 8;
  geom.vertices.push(new THREE.Vector3(cor.x, cor.y, 0));
  geom.vertices.push(new THREE.Vector3(cor.x + cor.y / len, cor.y - cor.x / len, 0));
  line = new THREE.Line(geom, new THREE.LineBasicMaterial({
    color: 0x800000,
    opacity: 0.25
  }));
  scene.add(line);
  geom = new THREE.Geometry();
  cor = baricentricToCartesian(1 / 3, 1 / 3, 0, R * z, -a / 2 * z, -r * z, a / 2 * z, -r * z);
  geom.vertices.push(new THREE.Vector3(cor.x, cor.y, 0));
  cor = baricentricToCartesian(j / 2, j / 2, 0, R * z, -a / 2 * z, -r * z, a / 2 * z, -r * z);
  len = Math.sqrt(cor.x * cor.x + cor.y * cor.y) * 8;
  geom.vertices.push(new THREE.Vector3(cor.x, cor.y, 0));
  geom.vertices.push(new THREE.Vector3(cor.x + cor.y / len, cor.y - cor.x / len, 0));
  line = new THREE.Line(geom, new THREE.LineBasicMaterial({
    color: 0x008000,
    opacity: 0.25
  }));
  scene.add(line);
  geom = new THREE.Geometry();
  cor = baricentricToCartesian(1 / 3, 1 / 3, 0, R * z, -a / 2 * z, -r * z, a / 2 * z, -r * z);
  geom.vertices.push(new THREE.Vector3(cor.x, cor.y, 0));
  cor = baricentricToCartesian(j / 2, 1 - j, 0, R * z, -a / 2 * z, -r * z, a / 2 * z, -r * z);
  len = Math.sqrt(cor.x * cor.x + cor.y * cor.y) * 8;
  geom.vertices.push(new THREE.Vector3(cor.x, cor.y, 0));
  geom.vertices.push(new THREE.Vector3(cor.x + cor.y / len, cor.y - cor.x / len, 0));
  line = new THREE.Line(geom, new THREE.LineBasicMaterial({
    color: 0x000080,
    opacity: 0.25
  }));
  scene.add(line);
}

baricentricPoint = function(u, v) {
  var p;

  z = 1;
  scene.add(p = new THREE.Particle(new THREE.ParticleCanvasMaterial({
    color: colors[Math.random() * colors.length | 0],
    opacity: 0.75,
    program: progFillSmall
  })));
  cor = baricentricToCartesian(u / 3, v / 3, 0, R * z, -a / 2 * z, -r * z, a / 2 * z, -r * z);
  p.position.x = cor.x;
  return p.position.y = cor.y;
};

cortesianPoint = function(x, y) {
  var p;

  z = 1;
  scene.add(p = new THREE.Particle(new THREE.ParticleCanvasMaterial({
    color: colors[Math.random() * colors.length | 0],
    opacity: 0.75,
    program: progStroke
  })));
  p.position.x = x;
  return p.position.y = y;
};

z = 1;

for (u = _j = -3; _j <= 9; u = ++_j) {
  for (v = _k = -3, _ref1 = 6 - u; -3 <= _ref1 ? _k <= _ref1 : _k >= _ref1; v = -3 <= _ref1 ? ++_k : --_k) {
    if (u % 3 && v % 3 && (3 - u - v) % 3) {
      baricentricPoint(u, v);
    }
  }
}

for (i = _l = -2; _l <= 2; i = ++_l) {
  for (j = _m = -1; _m <= 0; j = ++_m) {
    d = Math.abs((i + j + 1) % 2);
    x = i * a / 2.0 * z;
    y = j * a / 2.0 * s * z + r * (d * z - 1);
    cortesianPoint(x, -y);
  }
}
